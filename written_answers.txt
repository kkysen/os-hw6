Answers for parts  1 - 5
Enter your answers in the designated location. Do NOT remove lines that start
with '=' signs. Removing these lines will break our grading scrips and will
result in 0 points. Also, keep lines to a max of 80 chars long (you do not
need to worry if the top command is longer than 80 chars). Also, please limit
your answers to about 40 words.

================================== P1Q1 start ==================================
Describe how you created the 70%/30% split. 
    - Include the command lines you executed
    - Indicate if you needed root privileges for any of those commands
    - Include the top output

We ran the command
```shell
for i in {1..10}; do ( [[ $i -le 5 ]] && nice=-7 || nice=-3; taskset 1 nice $nice yes > /dev/null & ); done
```
to create the 70%/30% split.
10 processes were created, `yes > /dev/null` that stress the CPU,
then all were assigned to the 1st CPU using `taskset 1`,
and half were assigned `nice -7` and the other half `nice -3`,
which created the 70%/30% split.
Then we used `htop` to verify the split.

Root privileges were not necessary for any of these commands.

Here's the `htop` output, truncated to show only the `yes` commands and nothing below.
```htop
  1  [|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||100.0%]   5  [                                                                               0.0%]
  2  [                                                                               0.0%]   6  [                                                                               0.0%]
  3  [                                                                               0.0%]   7  [                                                                               0.0%]
  4  [                                                                               0.0%]   8  [|                                                                              0.7%]
  Mem[|||||||||                                                                618M/12.3G]   Tasks: 36, 53 thr; 8 running
  Swp[                                                                           0K/4.00G]   Load average: 9.99 7.53 4.06
                                                                                             Uptime: 22:13:01

  PID USER      PRI  NI  VIRT   RES   SHR S CPU% MEM%   TIME+  Command
 2330 kkysen     23   3  7236   588   520 R 14.6  0.0  0:57.21 yes
 2328 kkysen     23   3  7236   588   520 R 14.0  0.0  0:57.21 yes
 2332 kkysen     23   3  7236   524   456 R 14.0  0.0  0:57.21 yes
 2326 kkysen     23   3  7236   596   524 R 14.0  0.0  0:57.21 yes
 2324 kkysen     23   3  7236   596   524 R 14.0  0.0  0:57.21 yes
 2316 kkysen     27   7  7236   592   520 R  6.0  0.0  0:23.38 yes
 2320 kkysen     27   7  7236   592   520 R  6.0  0.0  0:23.38 yes
 2318 kkysen     27   7  7236   592   520 R  6.0  0.0  0:23.38 yes
 2314 kkysen     27   7  7236   524   456 R  6.0  0.0  0:23.38 yes
 2322 kkysen     27   7  7236   588   520 R  5.3  0.0  0:23.38 yes
```

=================================== P1Q1 end ===================================

================================== P1Q2 start ==================================
Describe how you created a real-time priority task.
    - Include the command lines you executed
    - Indicate if you needed root privileges for any of those commands
    - Include the top output

    /* TODO */ 

=================================== P1Q2 end ===================================



================================== P2Q1 start ==================================
The output of diff or diffconfig when comparing the config files for your 
mainline fallback kernel and your MuQSS kernel

    /* TODO */

=================================== P2Q1 end ===================================

================================== P2Q2 start ==================================
Indicate you successfully patched, built, and booted into your MuQSS-enabled 
Linux kernel.

    /* TODO */ 

=================================== P2Q2 end ===================================



================================== P3Q1 start ==================================
Describe how you created the 70%/30% split. 
    - Include the command lines you executed
    - Indicate if you needed root privileges for any of those commands
    - How were the results different from P1Q1, if at all.

    /* TODO */

=================================== P3Q1 end ===================================

================================== P3Q2 start ==================================
Describe how you created a real-time priority task. 
    - Include the command lines you executed
    - Indicate if you needed root privileges for any of those commands
    - How were the results different from P1Q2, if at all.

    /* TODO */ 

=================================== P3Q2 end ===================================

================================== P3Q3 start ==================================
MuQSS features unprivileged real-time tasks. Perform the previous task with and
without root privileges, and describe the differences. 

    /* TODO */

=================================== P3Q3 end ===================================



================================== P4Q1 start ==================================
Verify Con Kolivas' claim by timing the kernel build-time in both your fallback
and your MuQSS-patched kernels.
    
    /* TODO */ 

=================================== P4Q1 end ===================================

================================== P4Q2 start ==================================
Design an experiment that you think will highlight MuQSS’s strength. Perform 
the experiment and report your findings.

    /* TODO */ 

=================================== P4Q2 end ===================================



================================== P5Q1 start ==================================
Briefly describe the advantages and disadvantages of a larger HZ.

Advantages: A higher HZ/tick rate means that the timer interrupts
are more frequent and work can occur more frequently.
With higher HZ, error, which is 5 milliseconds/HZ or lower,
which means that there is more accuracy in timing, which is
important for preemption and functions that use timeouts or rely on timing.
There is also higher/finer resolution, which means
there are better measurement recordings.

Disadvantages: The higher HZ, the more time is spent doing
the actual timer interrupts, which grows the overhead.
This time eventually adds up and can lead to more of the cache memory
being overused and more power being used.

=================================== P5Q1 end ===================================

================================== P5Q2 start ==================================
What is the HZ currently configured for your running Linux system?

We created a simple kernel module that on module init prints out
the `USER_HZ` variable, which is a kernel constant.
The HZ currently configured for our running Linux system is 100.

`getconf CLK_TCK` also says `HZ` is 100.

=================================== P5Q2 end ===================================

================================== P5Q3 start ==================================
What are jiffies? Explain the relationship between jiffies, HZ, and time.

"Jiffies" is a variable that represents the number of ticks/timer interrupts
since the system boot. The number is generally set to
a specific (high) value on boot (in order to better catch overflows)
and when calculated that initial number is subtracted from the new value.
The HZ is equal to jiffies per second,
or rather, HZ jiffies happen every second.
The relationship between jiffies and time is that seconds = jiffies/HZ.

=================================== P5Q3 end ===================================

================================== P5Q4 start ==================================
Find the current value of jiffies in your system.
    - In minutes, how much time does this jiffies value represent?
    - Does it match the uptime reported by the uptime command? (Hint: it 
      doesn’t.) Please give the formula to convert jiffies to the current 
      (real) uptime, in minutes.
    - Why does this large difference exist? (Hint: in 32-bit Linux systems,
      jiffies is a 32-bit value.)

In Aliza’s system, jiffies is equal to 4296575070.
Seconds = jiffies/HZ = 4296575070/100 = 42965750.70/60 = 716095.845 minutes.
The time reported by the uptime command is 6731.23.

The formula to convert is *TODO*.

This large difference exists because in 32-bit Linux systems, jiffies is a
32-bit number. However, time is 64-bit on our 64-bit OS and hardware
and the initial jiffies is still a high 32-bit number. This means that
jiffies can increase much more before overflowing and wrapping around,
i.e. the time can continue for longer without overflow, skewing the values.

=================================== P5Q4 end ===================================

================================== P5Q5 start ==================================
What are Niffies? How do they differ from Jiffies?

Niffies are similar to jiffies except that they are calculated in nanoseconds
rather than seconds. In addition, niffies are calculated slightly differently
than jiffies because instead of being overall for the whole system that work off
the TSC timers for each runqueue, and are periodically synchronized if they cannot be
(when both runqueues are locked).

=================================== P5Q5 end ===================================
